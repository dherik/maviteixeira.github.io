---
layout: post
title:  "Keep all details hidden"
date:   2019-08-23 21:00:00
tags: architect, oop
comments: true
author: maviteixeira
preview: When working with integrations between different applications that are controlled by external teams we could get into some communication problems, specially if the company lack of the architect figure and let the teams do whatever they please without documenting and creating communications standards. 
image: https://maviteixeira.github.io/images/we_just_need_to_find_her.png
--- 

When working with integrations between different applications that usually are controlled by external teams eventually we can get into some communication problems, specially if the company lack of the [architect](https://maviteixeira.com/2019/08/02/software-architect.html) figure and let the teams do whatever they please without documenting and creating communications standards.

One of the most common issues is external applications sending the same data in different formats, forcing us to adapt our code to process all the non standard messages in completely different ways.

To ilustrate the problem let's say we need to integrate with 3 different applications, all of them are sending a String that identify the client, we need to find that client and process in different ways depending of the sender. 
The problem is that the client identification is not standard between applications and have the formats below:

FizzApplication - ``12345612341234123456``

BuzzApplication - ``CLIENT:12345612341234123456``

DogApplication  - ``123456-1234-1234123-456``

Usually when something like this happen we add a ``Parser``, ``Converter`` or maybe put all this logic in the service that is consuming this message like in the code below:

{% highlight java %}
    public class ClientService {
        private final ClientConverter clientConverter;
        Person fetch (int id);
        public Client findClient(ClientDto clientDto) {
            String clientIdentity = clientConverter.convertClientIdentity(clientDto.getIdentity());
            //Search in the database and return the Client
    }
{% endhighlight %}

The ``ClientService`` is receiving a ``DTO``, it's converting to the client identification as a common ``String`` and then is sending to the repository that will return a implementation of the ``Client`` interface.

Now let's take a look in the converter itself:

{% highlight java %}
    public class ClientConverter {
        private static final String SEPARATOR = "-";
        private static final String CLIENT = "CLIENT:";

        public String convertClientIdentity(String clientIdentity) {
            if (clientIdentity.contains(CLIENT)) {
                return clientIdentity.replace(CLIENT, "");
            }
            if (clientIdentity.contains(SEPARATOR)) {
                return clientIdentity.replace("-", "");
            }
            return clientIdentity;
        }
    }
{% endhighlight %}

In our case is pretty simple because our formats are easy to reason about it. But don't be fooled this class could get messy really quickly if somewhere in the future we need to add some validations or if in a specific format we need to do a HTTP request to decrypt the identification before return it. Anyway here some topics that ilustrate the major problems that I see with this approach:
 - The class ``ClientConverter`` doesn't mean anything to the business and we lose semantic value that would facilitate our undertanding.
 - This class will grow and become more complex and hard to test for every new non standard client identifier.
 - This class have no abstraction implementation details (needs a interface)
 - This class have too many responsabilities because need to check and convert 3 types of formats at once.

One thing that I encourage to always do is think about the meaning of things and design the interfaces accordingly, to make everything clear let's start with an example, first we need to find the meaning that in our case is obviously a client identifier that being said it's clear we should create the first abstraction:

{% highlight java %}
    public interface ClientIdentity {

        String value();

    }
{% endhighlight %}

This interface identify the contract that represent a client identification for the application, so we can go on changing the services to honor this contract:

{% highlight java %}
    public interface Clients extends Iterable<Client> {

        Client client(ClientIdentity identity);

    }
{% endhighlight %}

This interface will accept any implementation of the ``ClientIdentity`` and return a ``Client`` abstraction that will execute some process later. Because of this interface we can create implementations that will handle specific formats, for example let's assume that the first format should be the standard ``12345612341234123456``, so we could come up with a simple class that just return the ``String``:

{% highlight java %}
    public class FizzClientClientIdentity implements ClientIdentity {
        private final String identity;

        public FizzClientIdentity(String identity) {
            this.identity = identity;
        }

        public String value() {
            return identity;
        }
    }
{% endhighlight %}

This class handle the default format doing nothing as expected.

Now for the second format we need to remove some caracters before returning ``CLIENT:12345612341234123456``, here is the implementation for it:

{% highlight java %}
    public class BuzzClientIdentity implements ClientIdentity {
        private static final String CLIENT = "CLIENT:";
        private final String identity;

        public BuzzIdentity(String identity) {
            this.identity = identity;
        }

        public String value() {
            return identity.replace(CLIENT, "");
        }
    }
{% endhighlight %}

Same goes for the third and last format ``123456-1234-1234123-456``:

{% highlight java %}
    public class DogClientIdentity implements ClientIdentity {

        private static final String SEPARATOR = "-";
        private final String identity;

        public DogClientIdentity(String identity) {
            this.identity = identity;
        }

        public String value() {
            return identity.replace(SEPARATOR, "");
        }

    }
{% endhighlight %}

Now we have 3 classes that represent different formats but using the same contract ``ClientIdentity``, the ``Clients`` doesn't know what implementation are being pass and doesn't care either it will just follow the contract and ask for the value to search the client.
This add a flexibility to any number of formats to be handled and it will keep the classes short and cohesive, they are easy to test and reason about it and have meaning to the business.

To summarise, we need to pay more attention to the business and how we translate that into the code, thinking about our abstractions more carefully and use all the power that OOP is offering to avoid procedural code and classes that will grow indefinitely like our converter above.
After years doing the converter path I can't say it's easy to think this way, but surely is getting easier with time and if we want to deliver better software we need to keep learning and pay attention to details.